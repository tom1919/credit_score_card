else if(check_res$iv < 0.1) {
print(paste0(factor_names[i], " has iv less than .1"))
next
}
else {
result_all_sig_factor[[factor_names[i]]] <- check_res
print(paste0(factor_names[i], " has splits created"))
}
print(i)
print(i)
print(i)
}
i
smbinning.factor(df = train, y = "good", x = factor_names[11])
smbinning.factor(df = train, y = "good", x = factor_names[12])
factor_names[10]
factor_names[13]
train %>% select(PROF)
train<-  train %>% mutate(PRODUCT = str_replace_all(PRODUCT, ",", "_"),
PROF = str_replace_all(PROF, ",", "_"))
# col names of factor predictor variables
factor_names <- names(train)[sapply(train, is.factor)]
factor_names
train<-  train %>% mutate(PRODUCT = str_replace_all(PRODUCT, ",", "_"),
PROF = str_replace_all(PROF, ",", "_")) %>%
mutate_at(c("PRODUCT", "PROF"), funs(as.factor(.)))
# col names of factor predictor variables
factor_names <- names(train)[sapply(train, is.factor)]
factor_names
# smbinning expcts "good variable"
result_all_sig_factor <- list() # Creating empty list to store all results #
for(i in 1:length(factor_names)){
print(factor_names[i])
check_res <- smbinning.factor(df = train, y = "good", x = factor_names[i])
if(check_res == "No significant splits") {
print(paste0(factor_names[i], " has no sig splits"))
next
}
else if(check_res$iv < 0.1) {
print(paste0(factor_names[i], " has iv less than .1"))
next
}
else {
result_all_sig_factor[[factor_names[i]]] <- check_res
print(paste0(factor_names[i], " has splits created"))
}
print(i)
print(i)
print(i)
}
factor_names
length(result_all_sig_factor)
result_all_sig_factor[[1]]
result_all_sig_factor[[2]]
result_all_sig_factor[[3]]
result_all_sig_factor[[4]]
result_all_sig_factor[[2]]
result_all_sig_factor[[1]]
result_all_sig_factor[[1]]$iv
for(i in 1:length(result_all_sig))
result_all_sig[[i]]$iv
print(result_all_sig[[i]]$iv)}
for(i in 1:length(result_all_sig)){
print(result_all_sig[[i]]$iv)}
print(result_all_sig_factor[[i]])}
for(i in 1:length(result_all_sig_factor)){
print(result_all_sig_factor[[i]])}
result_all_sig_factor[[3]]
for(i in 1:length(result_all_sig_factor)){
print(result_all_sig_factor[[i]]$x)}
for(i in 1:length(result_all_sig)){
print(result_all_sig[[i]]$x)}
for(i in 1:length(result_all_sig_factor)){
print(result_all_sig_factor[[i]]$x)}
for(i in 1:length(result_all_sig)){
print(result_all_sig[[i]]$x)}
smbins <- list(result_all_sig, result_all_sig_factor)
for(i in 1:length(smbins)){
print(smbins[[i]]$x)
}
smbins <- c(result_all_sig, result_all_sig_factor)
for(i in 1:length(smbins)){
print(smbins[[i]]$x)
}
# Generating Variables of Bins and WOE Values #
for(i in 1:length(smbins)) {
train <- smbinning.gen(df = train, ivout = smbins[[i]],
chrname = paste(smbins[[i]]$x,
"_bin", sep = ""))
}
# Generating Variables of Bins and WOE Values #
# Generating Variables of Bins and WOE Values #
for(i in 1:length(result_all_sig)) {
train <- smbinning.gen(df = train, ivout = result_all_sig[[i]],
chrname = paste(result_all_sig[[i]]$x,
"_bin", sep = ""))
}
for (j in 1:length(result_all_sig)) {
for (i in 1:nrow(train)) {
bin_name <- paste(result_all_sig[[j]]$x, "_bin", sep = "")
bin <- substr(train[[bin_name]][i], 2, 2)
woe_name <- paste(result_all_sig[[j]]$x, "_WOE", sep = "")
if(bin == 0) {
bin <- dim(result_all_sig[[j]]$ivtable)[1] - 1
train[[woe_name]][i] <- result_all_sig[[j]]$ivtable[bin, "WoE"]
} else {
train[[woe_name]][i] <- result_all_sig[[j]]$ivtable[bin, "WoE"]
}
}
}
train
for(i in 1:length(smbins)) {
train <- smbinning.gen(df = train, ivout = smbins[[i]],
chrname = paste(smbins[[i]]$x,
"_bin", sep = ""))
}
smbins[[i]]
i
for(i in 1:length(result_all_sig_factor)) {
train <- smbinning.gen(df = train, ivout = result_all_sig_factor[[i]],
chrname = paste(result_all_sig_factor[[i]]$x,
"_bin", sep = ""))
}
smbinning.gen(df = train, ivout = result_all_sig[[1]],
chrname = paste(result_all_sig[[1]]$x,
"_bin", sep = ""))
smbinning.gen(df = train, ivout = result_all_sig_factor[[1]],
chrname = paste(result_all_sig_factor[[1]]$x,
"_bin", sep = ""))
smbinning.gen(df = train, ivout = result_all_sig_factor[[2]],
chrname = paste(result_all_sig_factor[[2]]$x,
"_bin", sep = ""))
rejects2 <- readRDS("../data/rejects_v2.rds")
train <- readRDS("../data/train.rds")
test <- readRDS("../data/test.rds")
train$good = abs(as.numeric(train$GB) - 2)
train <- train %>% select(good, everything(), -GB)
test$good = abs(as.numeric(test$GB) - 2)
test <- test %>% select(good, everything(), -GB, -id)
train<-  train %>% mutate(PRODUCT = str_replace_all(PRODUCT, ",", "_"),
PROF = str_replace_all(PROF, ",", "_")) %>%
mutate_at(c("PRODUCT", "PROF"), funs(as.factor(.)))
train<-  train %>% mutate(PRODUCT = str_replace_all(PRODUCT, ",", "_"),
PROF = str_replace_all(PROF, ",", "_")) %>%
mutate_at(c("PRODUCT", "PROF"), funs(as.factor(.)))
# col names of factor predictor variables
factor_names <- names(train)[sapply(train, is.factor)]
# loop through each numeric col and use smbinning to bin them into categories
# only create bins if unique vales > 5, there are significant splits and
# iv value is greater than 0.1
# smbinning expcts "good variable"
result_all_sig_factor <- list() # Creating empty list to store all results #
for(i in 1:length(factor_names)){
check_res <- smbinning.factor(df = train, y = "good", x = factor_names[i])
if(check_res == "No significant splits") {
print(paste0(factor_names[i], " has no sig splits"))
next
}
else if(check_res$iv < 0.1) {
print(paste0(factor_names[i], " has iv less than .1"))
next
}
else {
result_all_sig_factor[[factor_names[i]]] <- check_res
print(paste0(factor_names[i], " has splits created"))
}
}
smbinning.gen(df = train, ivout = result_all_sig_factor[[2]],
chrname = paste(result_all_sig_factor[[2]]$x,
"_bin", sep = ""))
result_all_sig_factor[[2]]
train
i = 1
smbinning.gen(df = train, ivout = result_all_sig[[i]],
chrname = paste(result_all_sig[[i]]$x,
"_bin", sep = ""))
smbins[[i]]
smbins[[2]]
smbins[[2]]
for(i in 1:length(smbins)){
print(smbins[[i]][2])
}
print(smbins[[i]][3])
print(smbins[[i]][4])
for(i in 1:length(smbins)){
print(smbins[[i]])
}
tables(train$CARDS)
table(train$CARDS)
table(test$CARDS)
smbinning.gen(df = train, ivout = result_all_sig_factor[[4]],
chrname = paste(result_all_sig_factor[[4]]$x,
"_bin", sep = ""))
result_all_sig_factor[[4]]
result_all_sig_factor[[1]]
result_all_sig_factor[[2]]
table(train$STATUS)
table(test$STATUS)
result_all_sig_factor[[3]]
table(test$CARDS)
table(rejects2$CARDS)
result_all_sig_factor[[4]]
result_all_sig_factor[[3]]
result_all_sig_factor[[2]]
result_all_sig_factor[[1]]
# helper functions
source("./helper_functions.R")
# load / install packages
LoadPackages(c("dplyr", 'haven', 'missForest', "stringr", "tibble"))
# read in data
accepts <- read_sas("../data/orginal/accepted_customers.sas7bdat")
rejects <- read_sas("../data/orginal/rejected_customers.sas7bdat")
# replace empty spaces with NA
accepts[accepts==""] <- NA
rejects[rejects==""] <- NA
summarize_df(accepts)
summarize_df(rejects)
not_in_accepts <- setdiff(names(rejects), names(accepts))
rejects <- rejects %>% select(setdiff( names(rejects), not_in_accepts))
all <- bind_rows(accepts, rejects)
# 123 NA values for time at address
all %>% filter(TMADD == 999) %>% nrow()
# 45 NA values for time at job
all %>% filter(TMJOB1 == 999) %>% nrow()
# Someone has 23 childern
table(all$CHILDREN)
# Someone has 25 in their household
table(all$PERS_H)
all <- all %>%
mutate(TMADD = ifelse(TMADD == 999, NA, TMADD),
TMJOB1 = ifelse(TMJOB1 == 999, NA, TMJOB1),
CHILDREN = ifelse(CHILDREN == 23, NA, CHILDREN),
PERS_H = ifelse(PERS_H == 25, NA, PERS_H))
# columns that should be factors
factor_cols <- c('TEL', 'STATUS', 'BUREAU', 'LOCATION', 'REGN', 'DIV', 'CARDS',
'PRODUCT', 'RESID', 'NAT', 'PROF', 'CAR', 'GB', 'TITLE',
'FINLOAN','EC_CARD')
# cast columns as factors
all <- all %>% mutate_at(factor_cols, funs(as.factor(.)))
missing_flags <- all %>%
mutate(TMADD_unk = ifelse(is.na(TMADD), 1, 0),
TMJOB1_unk = ifelse(is.na(TMJOB1), 1, 0),
RESID_unk = ifelse(is.na(RESID), 1, 0)) %>%
select(TMADD_unk, TMJOB1_unk, RESID_unk)
# not creating flag for product, children and pers_h because there was very
#  little missing
impute_df <- all %>% select(-GB, -`_freq_`) # don't use target for imputation
target <- all %>% select(GB, `_freq_`)
set.seed(888)
# impute with missForest package. it using random forest for imputation
mf_imp <- missForest(as.data.frame(impute_df), verbose = T)
# bind the df w/ target variable and the df w/ missing values imputed
all2 <- bind_cols(target, mf_imp$ximp)
# combine the df with imputed values and the df with flags indicating the
# observations that were orginally missing
all2 <- bind_cols(all2, missing_flags)
saveRDS(mf_imp, "../data/mf_imp.rds")
# separate the data back into the rejects and accepts
accepts2 <- all2 %>% filter(!is.na(GB))
rejects2 <- all2 %>% filter(is.na(GB)) %>%
as.data.frame()
# Split into train and test sets
set.seed(888)
# train set gets random 70% of data
train <- accepts2 %>% sample_frac(size = .7)
# test set gets the ones not in train
test <- accepts2 %>% anti_join(train, by = "id") %>%
as.data.frame()
# treat these vars as factors because they have 3 or less unq values
all2 <- all2 %>%
mutate_at(c('NMBLOAN', 'RESID', 'adult', 'TMADD_unk', 'TMJOB1_unk',
'RESID_unk', "CARDS"), funs(as.factor(.)))
all2 <- all2 %>%
mutate(# round children and pers_h to nearest integer (imputation fractions)
CHILDREN = round(CHILDREN),
PERS_H = round(PERS_H),
adult = PERS_H - CHILDREN, # of adults in household
cash_per_pers = CASH / PERS_H,
cash_per_adult = CASH / adult,
income_per_pers = INCOME / PERS_H,
income_per_adult = INCOME/ adult,
# if cash is zero then division by zero so just impute 1.5 (avg)
income_cash_ratio = ifelse(CASH == 0, 1.5, INCOME / CASH),
total_loans = LOANS + NMBLOAN,
CARDS = ifelse(CARDS %in% c("VISA Citibank",
"VISA mybank",
"VISA Others"), "VISA", CARDS))
id = row_number()) %>%
all2 <- all2 %>%
mutate(# round children and pers_h to nearest integer (imputation fractions)
CHILDREN = round(CHILDREN),
PERS_H = round(PERS_H),
adult = PERS_H - CHILDREN, # of adults in household
cash_per_pers = CASH / PERS_H,
cash_per_adult = CASH / adult,
income_per_pers = INCOME / PERS_H,
income_per_adult = INCOME/ adult,
# if cash is zero then division by zero so just impute 1.5 (avg)
income_cash_ratio = ifelse(CASH == 0, 1.5, INCOME / CASH),
total_loans = LOANS + NMBLOAN,
CARDS = ifelse(CARDS %in% c("VISA Citibank",
"VISA mybank",
"VISA Others"), "VISA", CARDS),
id = row_number()) %>%
select(GB, `_freq_`, id, everything())
# treat these vars as factors because they have 3 or less unq values
all2 <- all2 %>%
mutate_at(c('NMBLOAN', 'RESID', 'adult', 'TMADD_unk', 'TMJOB1_unk',
'RESID_unk', "CARDS"), funs(as.factor(.)))
# summary of the new data set
summarize_df(all2)
# separate the data back into the rejects and accepts
accepts2 <- all2 %>% filter(!is.na(GB))
rejects2 <- all2 %>% filter(is.na(GB)) %>%
as.data.frame()
# Split into train and test sets
set.seed(888)
# train set gets random 70% of data
train <- accepts2 %>% sample_frac(size = .7)
# test set gets the ones not in train
test <- accepts2 %>% anti_join(train, by = "id") %>%
as.data.frame()
# remove the id column
train <- train %>%
select(-id) %>%
as.data.frame()
saveRDS(accepts2, "../data/accepts_v2.rds")
saveRDS(rejects2, "../data/rejects_v2.rds")
saveRDS(train, "../data/train.rds")
saveRDS(test, "../data/test.rds")
# accepts2 <- readRDS("../data/accepts2.rds")
# rejects2 <- readRDS("../data/rejects_v2.rds")
# train <- readRDS("../data/train.rds")
# test <- readRDS("../data/test.rds")
rejects2 <- readRDS("../data/rejects_v2.rds")
train <- readRDS("../data/train.rds")
test <- readRDS("../data/test.rds")
train$good = abs(as.numeric(train$GB) - 2)
train <- train %>% select(good, everything(), -GB)
test$good = abs(as.numeric(test$GB) - 2)
test <- test %>% select(good, everything(), -GB, -id)
# col names of numeric predictor variables
num_names <- names(train )[sapply(train, is.numeric)]
num_names <- num_names[3:length(num_names)]
# loop through each numeric col and use smbinning to bin them into categories
# only create bins if unique vales > 5, there are significant splits and
# iv value is greater than 0.1
# smbinning expcts "good variable"
result_all_sig <- list() # Creating empty list to store all results #
for(i in 1:length(num_names)){
check_res <- smbinning(df = train, y = "good", x = num_names[i])
if(check_res == "Uniques values < 5") {
print(paste0(num_names[i], " has less than 5 unq values"))
next
}
else if(check_res == "No significant splits") {
print(paste0(num_names[i], " has no sig splits"))
next
}
else if(check_res$iv < 0.1) {
print(paste0(num_names[i], " has iv less than .1"))
next
}
else {
result_all_sig[[num_names[i]]] <- check_res
print(paste0(num_names[i], " has splits created"))
}
}
#Able to pull all information within list by variable name #
#result_all_sig$AGE$ivtable
num_names
train<-  train %>% mutate(PRODUCT = str_replace_all(PRODUCT, ",", "_"),
PROF = str_replace_all(PROF, ",", "_")) %>%
mutate_at(c("PRODUCT", "PROF"), funs(as.factor(.)))
# col names of factor predictor variables
factor_names <- names(train)[sapply(train, is.factor)]
# loop through each numeric col and use smbinning to bin them into categories
# only create bins if unique vales > 5, there are significant splits and
# iv value is greater than 0.1
# smbinning expcts "good variable"
result_all_sig_factor <- list() # Creating empty list to store all results #
for(i in 1:length(factor_names)){
check_res <- smbinning.factor(df = train, y = "good", x = factor_names[i])
if(check_res == "No significant splits") {
print(paste0(factor_names[i], " has no sig splits"))
next
}
else if(check_res$iv < 0.1) {
print(paste0(factor_names[i], " has iv less than .1"))
next
}
else {
result_all_sig_factor[[factor_names[i]]] <- check_res
print(paste0(factor_names[i], " has splits created"))
}
}
table(train$CARDS)
result_all_sig_factor[[1]]
result_all_sig_factor[[2]]
result_all_sig_factor[[3]]
all2 <- bind_cols(target, mf_imp$ximp)
# combine the df with imputed values and the df with flags indicating the
# observations that were orginally missing
all2 <- bind_cols(all2, missing_flags)
all2 <- all2 %>%
mutate(# round children and pers_h to nearest integer (imputation fractions)
CHILDREN = round(CHILDREN),
PERS_H = round(PERS_H),
adult = PERS_H - CHILDREN, # of adults in household
cash_per_pers = CASH / PERS_H,
cash_per_adult = CASH / adult,
income_per_pers = INCOME / PERS_H,
income_per_adult = INCOME/ adult,
# if cash is zero then division by zero so just impute 1.5 (avg)
income_cash_ratio = ifelse(CASH == 0, 1.5, INCOME / CASH),
total_loans = LOANS + NMBLOAN,
CARDS = ifelse(CARDS %in% c("VISA Citibank",
"VISA mybank",
"VISA Others"), "VISA",
as.character(CARDS)),
id = row_number()) %>%
select(GB, `_freq_`, id, everything())
# treat these vars as factors because they have 3 or less unq values
all2 <- all2 %>%
mutate_at(c('NMBLOAN', 'RESID', 'adult', 'TMADD_unk', 'TMJOB1_unk',
'RESID_unk', "CARDS"), funs(as.factor(.)))
# summary of the new data set
summarize_df(all2)
# separate the data back into the rejects and accepts
accepts2 <- all2 %>% filter(!is.na(GB))
rejects2 <- all2 %>% filter(is.na(GB)) %>%
as.data.frame()
# Split into train and test sets
set.seed(888)
# train set gets random 70% of data
train <- accepts2 %>% sample_frac(size = .7)
# test set gets the ones not in train
test <- accepts2 %>% anti_join(train, by = "id") %>%
as.data.frame()
# remove the id column
train <- train %>%
select(-id) %>%
as.data.frame()
saveRDS(accepts2, "../data/accepts_v2.rds")
saveRDS(rejects2, "../data/rejects_v2.rds")
saveRDS(train, "../data/train.rds")
saveRDS(test, "../data/test.rds")
rejects2 <- readRDS("../data/rejects_v2.rds")
train <- readRDS("../data/train.rds")
test <- readRDS("../data/test.rds")
train$good = abs(as.numeric(train$GB) - 2)
train <- train %>% select(good, everything(), -GB)
test$good = abs(as.numeric(test$GB) - 2)
test <- test %>% select(good, everything(), -GB, -id)
# col names of numeric predictor variables
num_names <- names(train )[sapply(train, is.numeric)]
num_names <- num_names[3:length(num_names)]
# loop through each numeric col and use smbinning to bin them into categories
# only create bins if unique vales > 5, there are significant splits and
# iv value is greater than 0.1
# smbinning expcts "good variable"
result_all_sig <- list() # Creating empty list to store all results #
for(i in 1:length(num_names)){
check_res <- smbinning(df = train, y = "good", x = num_names[i])
if(check_res == "Uniques values < 5") {
print(paste0(num_names[i], " has less than 5 unq values"))
next
}
else if(check_res == "No significant splits") {
print(paste0(num_names[i], " has no sig splits"))
next
}
else if(check_res$iv < 0.1) {
print(paste0(num_names[i], " has iv less than .1"))
next
}
else {
result_all_sig[[num_names[i]]] <- check_res
print(paste0(num_names[i], " has splits created"))
}
}
#Able to pull all information within list by variable name #
#result_all_sig$AGE$ivtable
train<-  train %>% mutate(PRODUCT = str_replace_all(PRODUCT, ",", "_"),
PROF = str_replace_all(PROF, ",", "_")) %>%
mutate_at(c("PRODUCT", "PROF"), funs(as.factor(.)))
# col names of factor predictor variables
factor_names <- names(train)[sapply(train, is.factor)]
# loop through each numeric col and use smbinning to bin them into categories
# only create bins if unique vales > 5, there are significant splits and
# iv value is greater than 0.1
# smbinning expcts "good variable"
result_all_sig_factor <- list() # Creating empty list to store all results #
for(i in 1:length(factor_names)){
check_res <- smbinning.factor(df = train, y = "good", x = factor_names[i])
if(check_res == "No significant splits") {
print(paste0(factor_names[i], " has no sig splits"))
next
}
else if(check_res$iv < 0.1) {
print(paste0(factor_names[i], " has iv less than .1"))
next
}
else {
result_all_sig_factor[[factor_names[i]]] <- check_res
print(paste0(factor_names[i], " has splits created"))
}
}
result_all_sig_factor[[3]]
# collaspe the visa variable in data prep
table(test$CARDS)
table(train$CARDS)
