sm_result2 <- sig_bins(df = train,
col_names = factor_names,
numeric = F,
good_col = "good")
# numeric variables bins
train <- bin_cols(sm_result1, df = train, numeric = T)
# factor varialbes bins
train <- bin_cols(sm_result2, df = train, numeric = F)
# test set: numeric variables bins
test <- bin_cols(sm_result1, df = test, numeric = T)
# test set: factor varialbes bins
test <- bin_cols(sm_result2, df =test, numeric = F)
# train set: woe values for numeric variables
train <- gen_woe(sm_result1, df = train)
# train set: woe values for factor varialbes
train <- gen_woe(sm_result2, df = train)
# test set woe values for numeric variables
test <- gen_woe(sm_result1, df = test)
# test set: woe values for factor varialbes
test <- gen_woe(sm_result2, df = test)
train2 <- train %>% select(GB, `_freq_`, ends_with("WOE"))
train2 <- train2 %>% select(GB,
`_freq_`,
AGE_WOE,
TMJOB1_WOE,
income_cash_ratio_WOE,
CARDS_WOE, adult_WOE )
# create log regression model
score_card1 <- glm(data = train2, GB ~ . -`_freq_`,
weights = train$`_freq_`,
family = "binomial",
control = list(maxit = 100))
# coefs, pvalues etc of model
summary(score_card1)
# predict on test set (used by smbinnin.metrics)
test$pred <- predict(score_card1, newdata=test, type='response')
# cast as numeric (bc smbinning needs numeric)
test$GB <- as.character(test$GB) %>% as.numeric()
# model performance on test set
smbinning.metrics(dataset = test, prediction = "pred",
actualclass = "GB", report = 1)
# numeric variables bins
rejects_scored <- bin_cols(sm_result1, df = rejects2, numeric = T)
# factor varialbes bins
rejects_scored <- bin_cols(sm_result2, df =rejects_scored, numeric = F)
# woe values for numeric variables
rejects_scored <- gen_woe(sm_result1, df = rejects_scored)
# woe values for factor varialbes
rejects_scored <- gen_woe(sm_result2, df = rejects_scored)
# predict prob on reject set
rejects_scored$pred <- predict(score_card1, newdata=rejects_scored,
type='response')
# label 1 or 0 based on optimum cutoff from smbinnimg report
rejects2$GB <- as.numeric(rejects_scored$pred > 0.0286)
# add weights based of 75% acceptance rate and 30:1 odds for bad:good
rejects2$`_freq_` <- ifelse(rejects2$GB == 1, 1, 30)
# addjust weights for accepts set so it's proportional to rejects
accepts2$`_freq_` <- accepts2$`_freq_` * 3
# combine the accepts and rejects sets
comb <- rbind(accepts2, rejects2)
set.seed(8888)
train_id <- sample(seq_len(nrow(comb)), size = floor(0.70*nrow(comb)))
train_comb <- comb[train_id, ]
test_comb <- comb[-train_id, ]
# create good variable and reorder cols (smbin needs same order and good var)
test_comb$good <- abs(as.numeric(test_comb$GB) - 2)
test_comb <- test_comb %>% select(GB, `_freq_`, good, everything())
train_comb$good <- abs(as.numeric(train_comb$GB) - 2)
train_comb <- train_comb %>% select(GB, `_freq_`, good, everything())
# col names of numeric predictor variables
num_names <- names(train_comb )[sapply(train_comb, is.numeric)]
num_names <- num_names[4:length(num_names)]
sm_result3 <- sig_bins(df = train_comb,
col_names = num_names,
numeric = T,
good_col = "good")
# col names of factor predictor variables
factor_names <- names(train_comb)[sapply(train_comb, is.factor)]
factor_names <- factor_names[2:length(factor_names)]
sm_result4 <- sig_bins(df = train_comb,
col_names = factor_names,
numeric = F,
good_col = "good")
# numeric variables bins
train_comb <- bin_cols(sm_result3, df = train_comb, numeric = T)
# factor varialbes bins
train_comb <- bin_cols(sm_result4, df = train_comb, numeric = F)
# woe values for numeric variables
train_comb <- gen_woe(sm_result3, df = train_comb)
# woe values for factor varialbes
train_comb <- gen_woe(sm_result4, df = train_comb)
for(i in names(sm_result3)) {
sm_result3[[i]]$bands[1] <- min(test_comb[[i]], na.rm = TRUE)
sm_result3[[i]]$bands[length(sm_result3[[i]]$bands)] <- max(test_comb[[i]],
na.rm = TRUE)
}
# add a copy of obs with motorbike from train set into test set
# bc test set doesn't have one and caused error with smbinning gen
# should have one hot encodedeverything from the start
dupe_obs <- train_comb %>% filter(CAR == 'Motorbike') %>% slice(1)
test_comb <- bind_rows(test_comb, dupe_obs %>% select(names(test_comb)))
# numeric variables bins
test_comb <- bin_cols(sm_result3, df = test_comb, numeric = T)
# factor varialbes bins
test_comb <- bin_cols(sm_result4, df = test_comb, numeric = F)
# woe values for numeric variables
test_comb <- gen_woe(sm_result3, df = test_comb)
# woe values for factor varialbes
test_comb <- gen_woe(sm_result4, df = test_comb)
train_comb2 <- train_comb %>% select(GB, `_freq_`, ends_with('WOE')) %>%
select(-CHILDREN_WOE, -EC_CARD_WOE, -STATUS_WOE, -PERS_H_WOE,
-income_per_pers_WOE, -income_per_adult_WOE )
score_card2 <- glm(data = train_comb2, GB ~ . -`_freq_`,
weights = train_comb$`_freq_`,
family = "binomial",
control = list(maxit = 100))
summary(score_card2)
# predict on test set
test_comb$pred <- predict(score_card2, newdata=test_comb, type='response')
# cast as numeric (bc smbinning needs numeric)
test_comb$GB <- as.character(test_comb$GB) %>% as.numeric()
# model performance on test set
smbinning.metrics(dataset = test_comb, prediction = "pred",
actualclass = "GB", report = 1)
train_comb$set <- "train"
train_comb$GB <- as.character(train_comb$GB) %>% as.numeric()
test_comb$set <- "test"
all_scored <- bind_rows(train_comb, test_comb %>%
select(names(train_comb))) %>%
as.data.frame()
# generate a score for each person
all_scored <- allocate_points(mod = score_card2, df = all_scored,
pdo = 50, score = 500, odds = 20)
# create buckets / categories for the scores
all_scored$buckets <- cut(all_scored$Score, breaks = c(seq(300, 750, 50)))
# create predicted probabilities for each person
all_scored$pred <- predict(score_card2, newdata=all_scored, type='response')
# average prob for each score bucket
prob_score_bucket <- all_scored %>%
group_by(buckets) %>%
summarize(avg_prob = mean(pred))
# bad rate for each score bucket
bad_rate_bucket <- all_scored %>%
group_by(buckets) %>%
summarize(count = n(), bad_n = sum(GB) , default_rate = bad_n / count)
# create vector of the bin variable names
bin_cols <- score_card2$coefficients[-1] %>%
names %>%
str_replace_all("_WOE", "_bin")
# create vector of the points variable names
points_cols <- score_card2$coefficients[-1] %>%
names %>%
str_replace_all("_WOE", "_points")
# create data frame with just the bin and points columns
score_card_cols <- all_scored %>% select(bin_cols, points_cols)
# create a list of DFs where each df has the bin and points associated with it
# for each predictor
score_list <- list()
for(i in 1:length(bin_cols)) {
# DF for bins and points associated w/ it for each predictor
score_card_temp <- score_card_cols %>%
select(i, i+length(bin_cols)) %>%
distinct()
score_card_temp$var <- names(score_card_temp)[1]
names(score_card_temp) <- c('bin', 'points', 'var')
score_card_temp$bin <- as.character(score_card_temp$bin)
score_card_temp <- score_card_temp %>% arrange(bin)
score_list[[i]] <- score_card_temp
}
score_card <- do.call(bind_rows, score_list) %>% mutate(points = round(points))
test_scored <- all_scored %>% filter(set == "test")
accepts_n <- c(test_scored %>% filter(Score > 320) %>% nrow())
bad_n <- c(test_scored %>% filter(Score > 320 & GB ==1) %>% nrow())
good_n <- c(test_scored %>% filter(Score > 320 & GB ==0) %>% nrow())
for(cut in 321:600){
num_accept <- test_scored %>% filter(Score > cut) %>% nrow()
accepts_n <- c(accepts_n, num_accept)
num_bad <- test_scored %>% filter(Score > cut & GB ==1) %>% nrow()
bad_n <- c(bad_n, num_bad)
num_good <- test_scored %>% filter(Score > cut & GB ==0) %>% nrow()
good_n <- c(good_n, num_good)
}
cutoffs <- data.frame('cutoff' = 320:600,
'accepts_n' = accepts_n,
"bad_n" = bad_n,
"good_n" = good_n)
cutoffs %>% mutate(total_n = nrow(test_scored),
accepts_per = accepts_n / total_n,
bad_per = bad_n / accepts_n)
test_scored
test_scored %>% filter(Score > 320)
test_scored %>% filter(Score > 320) %>% group_by(`_freq`)
test_scored %>% filter(Score > 320) %>% group_by(`_freq_`) %>%
summarize(n())
glm(data = train_comb2, GB ~ . -`_freq_`,
weights = train_comb$`_freq_`,
family = "binomial",
control = list(maxit = 100))
test_scored %>% filter(Score > 320) %>% group_by(`_freq_`) %>%
summarize(n = n(),
adj_n = `_freq_` * n)
test_scored %>% filter(Score > 320) %>% group_by(`_freq_`) %>%
summarize(n = n()
)
test_scored %>% filter(Score > 320) %>% group_by(`_freq_`) %>%
summarize(n = n(),
adj_n = `_freq_` * n)
test_scored %>% filter(Score > 320) %>% group_by(`_freq_`) %>%
summarize(n = n())
test_scored %>% filter(Score > 320) %>% group_by(`_freq_`) %>%
summarize(n = n()) %>%
mutate(`_freq` * n)
test_scored %>% filter(Score > 320) %>% group_by(`_freq_`) %>%
summarize(n = n()) %>%
mutate(`_freq_` * n)
test_scored %>% filter(Score > 320) %>% group_by(`_freq_`) %>%
summarize(n = n()) %>%
mutate(adj_n = `_freq_` * n)
test_scored %>% filter(Score > 320) %>% group_by(`_freq_`) %>%
summarize(n = n()) %>%
pull(adj_n)
test_scored %>% filter(Score > 320) %>% group_by(`_freq_`) %>%
summarize(n = n()) %>%
mutate(adj_n = `_freq_` * n) %>%
pull(adj_n)
test_scored %>% filter(Score > 320) %>% group_by(`_freq_`) %>%
summarize(n = n()) %>%
mutate(adj_n = `_freq_` * n)
test_scored %>% filter(Score > 320) %>% group_by(`_freq_`) %>%
summarize(n = n()) %>%
mutate(adj_n = `_freq_` * n) %>%
pull(adj_n) %>% sum()
df2 <-
test_scored[rep(seq_along(test_scored$`_freq_`), test_scored$`_freq_`), ]
df2
df2$`_freq_` %>% table()
df2$`_freq_` %>% table() / nrow()
df2$`_freq_` %>% table() / nrow(df2)
.855576+.03
test_comb$`_freq_` %>% table() / nrow(test_comb)
39330 / 90
test_comb$`_freq_` %>% table()
4950 / 30
test_adj <- test_scored[rep(seq_along(test_scored$`_freq_`),
test_scored$`_freq_`), ]
test_adj <- test_scored[rep(seq_along(test_scored$`_freq_`),
test_scored$`_freq_`), ]
LoadPackages(c("dplyr", "smbinning", "stringr",
"tibble", "gmodels", "vcd", "caret"))
train_id <- createDataPartition(y = comb$`_freq`, p = .7, list = F)
train_comb <- comb[train_id, ]
test_comb <- comb[-train_id, ]
set.seed(8888)
train_id <- createDataPartition(y = comb$`_freq`, p = .7, list = F)
train_comb <- comb[train_id, ]
test_comb <- comb[-train_id, ]
# create good variable and reorder cols (smbin needs same order and good var)
test_comb$good <- abs(as.numeric(test_comb$GB) - 2)
test_comb <- test_comb %>% select(GB, `_freq_`, good, everything())
train_comb$good <- abs(as.numeric(train_comb$GB) - 2)
train_comb <- train_comb %>% select(GB, `_freq_`, good, everything())
# col names of numeric predictor variables
num_names <- names(train_comb )[sapply(train_comb, is.numeric)]
num_names <- num_names[4:length(num_names)]
sm_result3 <- sig_bins(df = train_comb,
col_names = num_names,
numeric = T,
good_col = "good")
# col names of factor predictor variables
factor_names <- names(train_comb)[sapply(train_comb, is.factor)]
factor_names <- factor_names[2:length(factor_names)]
sm_result4 <- sig_bins(df = train_comb,
col_names = factor_names,
numeric = F,
good_col = "good")
# numeric variables bins
train_comb <- bin_cols(sm_result3, df = train_comb, numeric = T)
source("../code/helper_functions.R")
LoadPackages(c("dplyr", "smbinning", "stringr",
"tibble", "gmodels", "vcd", "caret"))
select <- dplyr::select
# numeric variables bins
train_comb <- bin_cols(sm_result3, df = train_comb, numeric = T)
# factor varialbes bins
train_comb <- bin_cols(sm_result4, df = train_comb, numeric = F)
# woe values for numeric variables
train_comb <- gen_woe(sm_result3, df = train_comb)
# woe values for factor varialbes
train_comb <- gen_woe(sm_result4, df = train_comb)
for(i in names(sm_result3)) {
sm_result3[[i]]$bands[1] <- min(test_comb[[i]], na.rm = TRUE)
sm_result3[[i]]$bands[length(sm_result3[[i]]$bands)] <- max(test_comb[[i]],
na.rm = TRUE)
}
# add a copy of obs with motorbike from train set into test set
# bc test set doesn't have one and caused error with smbinning gen
# should have one hot encodedeverything from the start
dupe_obs <- train_comb %>% filter(CAR == 'Motorbike') %>% slice(1)
test_comb <- bind_rows(test_comb, dupe_obs %>% select(names(test_comb)))
# numeric variables bins
test_comb <- bin_cols(sm_result3, df = test_comb, numeric = T)
# factor varialbes bins
test_comb <- bin_cols(sm_result4, df = test_comb, numeric = F)
# woe values for numeric variables
test_comb <- gen_woe(sm_result3, df = test_comb)
# woe values for factor varialbes
test_comb <- gen_woe(sm_result4, df = test_comb)
train_comb2 <- train_comb %>% select(GB, `_freq_`, ends_with('WOE')) %>%
select(-CHILDREN_WOE, -EC_CARD_WOE, -STATUS_WOE, -PERS_H_WOE,
-income_per_pers_WOE, -income_per_adult_WOE )
train_comb2 <- train_comb %>% select(GB, `_freq_`, ends_with('WOE'))
score_card2 <- glm(data = train_comb2, GB ~ . -`_freq_`,
weights = train_comb$`_freq_`,
family = "binomial",
control = list(maxit = 100))
summary(score_card2)
train_comb2 <- train_comb %>% select(GB, `_freq_`, ends_with('WOE')) %>%
select( -EC_CARD_WOE, -STATUS_WOE, -PERS_H_WOE,
-income_per_pers_WOE, -income_per_adult_WOE )
score_card2 <- glm(data = train_comb2, GB ~ . -`_freq_`,
weights = train_comb$`_freq_`,
family = "binomial",
control = list(maxit = 100))
summary(score_card2)
# predict on test set
test_comb$pred <- predict(score_card2, newdata=test_comb, type='response')
# cast as numeric (bc smbinning needs numeric)
test_comb$GB <- as.character(test_comb$GB) %>% as.numeric()
# model performance on test set
smbinning.metrics(dataset = test_comb, prediction = "pred",
actualclass = "GB", report = 1)
train_comb$set <- "train"
train_comb$GB <- as.character(train_comb$GB) %>% as.numeric()
test_comb$set <- "test"
all_scored <- bind_rows(train_comb, test_comb %>%
select(names(train_comb))) %>%
as.data.frame()
# generate a score for each person
all_scored <- allocate_points(mod = score_card2, df = all_scored,
pdo = 50, score = 500, odds = 20)
# create buckets / categories for the scores
all_scored$buckets <- cut(all_scored$Score, breaks = c(seq(300, 750, 50)))
# create predicted probabilities for each person
all_scored$pred <- predict(score_card2, newdata=all_scored, type='response')
# average prob for each score bucket
prob_score_bucket <- all_scored %>%
group_by(buckets) %>%
summarize(avg_prob = mean(pred))
# bad rate for each score bucket
bad_rate_bucket <- all_scored %>%
group_by(buckets) %>%
summarize(count = n(), bad_n = sum(GB) , default_rate = bad_n / count)
prob_score_bucket
bad_rate_bucket
# create vector of the bin variable names
bin_cols <- score_card2$coefficients[-1] %>%
names %>%
str_replace_all("_WOE", "_bin")
# create vector of the points variable names
points_cols <- score_card2$coefficients[-1] %>%
names %>%
str_replace_all("_WOE", "_points")
# create data frame with just the bin and points columns
score_card_cols <- all_scored %>% select(bin_cols, points_cols)
# create a list of DFs where each df has the bin and points associated with it
# for each predictor
score_list <- list()
for(i in 1:length(bin_cols)) {
# DF for bins and points associated w/ it for each predictor
score_card_temp <- score_card_cols %>%
select(i, i+length(bin_cols)) %>%
distinct()
score_card_temp$var <- names(score_card_temp)[1]
names(score_card_temp) <- c('bin', 'points', 'var')
score_card_temp$bin <- as.character(score_card_temp$bin)
score_card_temp <- score_card_temp %>% arrange(bin)
score_list[[i]] <- score_card_temp
}
score_card <- do.call(bind_rows, score_list) %>% mutate(points = round(points))
score_card
bad_rate_bucket
prob_score_bucket
bad_rate_bucket
scored_adj <- all_scored[rep(seq_along(all_scoredd$`_freq_`),
all_scored$`_freq_`), ]
scored_adj <- all_score[rep(seq_along(all_scoredd$`_freq_`),
all_scored$`_freq_`), ]
scored_adj <- all_scored[rep(seq_along(all_scored$`_freq_`),
all_scored$`_freq_`), ]
scored_adj
# average prob for each score bucket
prob_score_bucket <- scored_adj %>%
group_by(buckets) %>%
summarize(avg_prob = mean(pred))
# bad rate for each score bucket
bad_rate_bucket <- scored_adj %>%
group_by(buckets) %>%
summarize(count = n(), bad_n = sum(GB) , default_rate = bad_n / count)
prob_score_bucket
bad_rate_bucket
scored_adj$GB %>% table
scored_adj$GB %>% table / nrow(scored_adj)
test_scored <- scored_adj %>% filter(set == "test")
accepts_n <- c(test_scored %>% filter(Score > 320) %>% nrow())
bad_n <- c(test_scored %>% filter(Score > 320 & GB ==1) %>% nrow())
good_n <- c(test_scored %>% filter(Score > 320 & GB ==0) %>% nrow())
for(cut in 321:600){
num_accept <- test_scored %>% filter(Score > cut) %>% nrow()
accepts_n <- c(accepts_n, num_accept)
num_bad <- test_scored %>% filter(Score > cut & GB ==1) %>% nrow()
bad_n <- c(bad_n, num_bad)
num_good <- test_scored %>% filter(Score > cut & GB ==0) %>% nrow()
good_n <- c(good_n, num_good)
}
cutoffs <- data.frame('cutoff' = 320:600,
'accepts_n' = accepts_n,
"bad_n" = bad_n,
"good_n" = good_n)
cutoffs %>% mutate(total_n = nrow(test_scored),
accepts_per = accepts_n / total_n,
bad_per = bad_n / accepts_n)
cutoffs %>% mutate(total_n = nrow(test_scored),
accepts_per = accepts_n / total_n,
bad_per = bad_n / accepts_n,
good_rev = 2000 * good_n,
bad_cost = -52000 * bad_n
profit = good_rev - bad_cost)
cutoffs %>% mutate(total_n = nrow(test_scored),
accepts_per = accepts_n / total_n,
bad_per = bad_n / accepts_n,
good_rev = 2000 * good_n,
bad_cost = -52000 * bad_n,
profit = good_rev - bad_cost)
cutoffs %>% mutate(total_n = nrow(test_scored),
accepts_per = accepts_n / total_n,
bad_per = bad_n / accepts_n,
good_rev = 2000 * good_n,
bad_cost = -52000 * bad_n,
profit = good_rev + bad_cost)
45000/1000
cutoffs %>% mutate(total_n = nrow(test_scored),
accepts_per = accepts_n / total_n,
bad_per = bad_n / accepts_n,
good_rev = 2000 * good_n,
bad_cost = -52000 * bad_n,
profit = good_rev + bad_cost,
profit_per_1000 = profit / (nrow(test_scored)/1000))
cutoffs %>% mutate(total_n = nrow(test_scored),
accepts_per = accepts_n / total_n,
bad_per = bad_n / accepts_n,
good_rev = 2000 * good_n,
bad_cost = -52000 * bad_n,
profit = good_rev + bad_cost,
profit_per_1000 = profit / (nrow(test_scored)))
cutoffs %>% mutate(total_n = nrow(test_scored),
accepts_per = accepts_n / total_n,
bad_per = bad_n / accepts_n,
good_rev = 2000 * good_n,
bad_cost = -52000 * bad_n,
profit = good_rev + bad_cost,
profit_per_1000 = profit / (nrow(test_scored)) * 1000)
cutoffs %>% mutate(total_n = nrow(test_scored),
accepts_per = accepts_n / total_n,
bad_per = bad_n / accepts_n,
good_rev = 2000 * good_n,
bad_cost = -52000 * bad_n,
profit = good_rev + bad_cost,
profit_per_cust = profit / (nrow(test_scored)))
cutoffs <- data.frame('cutoff' = 320:600,
'accepts_n' = accepts_n,
"bad_n" = bad_n,
"good_n" = good_n) %>% mutate(total_n = nrow(test_scored),
accepts_per = accepts_n / total_n,
bad_per = bad_n / accepts_n,
good_rev = 2000 * good_n,
bad_cost = -52000 * bad_n,
profit = good_rev + bad_cost,
profit_per_cust = profit / (nrow(test_scored)))
cutoffs
table(test_scored$Score)
summary(test_scored$Score)
test_scored <- scored_adj %>% filter(set == "test")
accepts_n <- c(test_scored %>% filter(Score > 400) %>% nrow())
bad_n <- c(test_scored %>% filter(Score > 400 & GB ==1) %>% nrow())
good_n <- c(test_scored %>% filter(Score > 400 & GB ==0) %>% nrow())
for(cut in 401:600){
num_accept <- test_scored %>% filter(Score > cut) %>% nrow()
accepts_n <- c(accepts_n, num_accept)
num_bad <- test_scored %>% filter(Score > cut & GB ==1) %>% nrow()
bad_n <- c(bad_n, num_bad)
num_good <- test_scored %>% filter(Score > cut & GB ==0) %>% nrow()
good_n <- c(good_n, num_good)
}
cutoffs <- data.frame('cutoff' = 400:600,
'accepts_n' = accepts_n,
"bad_n" = bad_n,
"good_n" = good_n) %>%
mutate(total_n = nrow(test_scored),
accepts_per = accepts_n / total_n,
bad_per = bad_n / accepts_n,
good_rev = 2000 * good_n,
bad_cost = -52000 * bad_n,
profit = good_rev + bad_cost,
profit_per_cust = profit / (nrow(test_scored)))
test_scored$GB %>% table() / nrow(test_scored)
rejects2$GB %>% table()
cutoffs
test$CASH %>% summary()
test$INCOME %>% summary()
test$INCOME %>% summary() * 1000
test$INCOME %>% summary() * 100
test$CASH %>% summary() * 100
